import './bots.css';

import { sendMessage, TChatterInfo } from '../chatters';
import { UTILITY_BOT_ID } from './utility/utility';

/** Separator used to split command parameters. */
export const PARAM_SEPARATOR: string = '?';

export type TBotInfo = Readonly<{
	/** The bot's description. */
	description: string;
	/** Main part of the bot's corresponding API url. */
	apiBaseUrl: string;
	/** Greeting used for the `hello` comand. */
	introduction: string;
} & TChatterInfo>;

export type TBot = Readonly<{
	/**
	 * Searches the message sent by the app's user passed as parameter for any executable commands.
	 * @param message Message content in which to look for commands.
	 */
	interpretMessage: (message: string) => void;
} & TBotInfo>;

export type TCommand = Readonly<{
	/** Main part of the command. */
	body: string;
	/** Bot the command is associated to. */
	bot: TBotInfo;
	/** Description of the command (used for the `commandinfo` command). */
	description: string;
	/** Command parameters. */
	params?: TParam[];
	/**
	 * Function to run when this command is used by the app's user.
	 * @param params Parameters (if any) of the command.
	*/
	execute: (params?: string[]) => void;
	/**
	 * Function to execute when the command is called with the wrong amount of parameters.
	 * @param nbParams The number of parameters the command should have.
	*/
	throwInvalidParamsError?: (nbParams: number) => void;
}>;

export type TParam = Readonly<{
	/** Parameter name (used for the `commandinfo` command). */
	name: string;
}>;

export type TBotQuery<TResponseType = any> = Readonly<{
	/** Request method. */
	method: string;
	/** Second half of the request url. */
	url: string;
	/** Body (if any) of the request. */
	body?: BodyInit;
	/**
	 * Callback to execute when a response is received.
	 * @param responseData Response given by the request.
	 */
	onResponseCallback: (responseData: TResponseType) => void;
}>;

/**
 * Iterates on the `array` passed as parameter, executing the `callback` for each of its element.
 * 
 * The `callback` is expected to return a `string` representing an HTML element,
 * as this function is made to work similarly to using `array.map()` to return JSX elements in React.
 * @param array Array to iterate on.
 * @param callback Callback used for every element in the array.
 * @returns A string representing all of the HTML elements generated by the callback.
 */
export function mapToHTMLString<TElementType>(
	array: TElementType[],
	callback: (element: TElementType) => string,
): string {
	return array.map(callback).join('');
}

/**
 * Sends an "Invalid parameters" error message.
 * @param bot Bot sending the message. 
 * @param nbParams Number of parameters the command should have.
 */
export function sendInvalidParamsMessage(bot: TChatterInfo, nbParams: number) {
	const mockParams: string[] = [];

	for (let i = 0; i < nbParams; i++) {
		mockParams.push(`${PARAM_SEPARATOR}param${i + 1}`);
	}

	sendMessage(
		bot,
		`<div class="invalid-params-message">
			<span>
				This command requires ${nbParams} parameters to work.
				Make sure you are using the following format before trying again:
			</span>

			<span>
				commandBody ${mockParams.join(' ')}
			</span>
		</div>`,
		true,
	);
}

/**
 * Looks through the user's message passed as parameter to try and find an executable command.
 * @param message Content of the message sent by the user to be interpreted by the bot.
 * @param commands Bot commands to be looking for in the user's message.
 */
function interpretMessage(message: string, commands: ReadonlyArray<TCommand>) {
	const formattedMessage: string[] = message.toLowerCase().replace(/\s+/g, '').split(PARAM_SEPARATOR);
	const body: string = formattedMessage[0];
	const params: string[] = formattedMessage.slice(1, formattedMessage.length);

	commands.forEach(command => {
		if (body !== command.body) return;

		if (command.params) {
			if (command.params.length === params.length && params.every(param => param !== '')) {
				command.execute(params);
				return;
			}

			command.throwInvalidParamsError?.(command.params.length);
			return;
		}

		command.execute();
	});
}

/**
 * API call function.
 * @param query Query to send to the API.
 */
export async function queryApi<TResponseType>(query: TBotQuery<TResponseType>) {
	await fetch(query.url, {
		method: query.method,
		body: query?.body,
	})
		.then(response => response.json())
		.then(responseData => query.onResponseCallback(responseData as TResponseType))
		.catch(error => console.error(error));
}

/**
 * Completes a bot by giving it the default command `hello` and default function `interpretMessage`.
 * @param botInfo Bot infos to complete.
 * @param commands Bot commands to complete with the `hello` default command.
 * @returns A `TBot` object made from the `TBotInfo` object passed as parameter.
 */
export function createBot(botInfo: TBotInfo, commands: TCommand[]): TBot {
	const commandsWithDefault: TCommand[] = commands;

	if (botInfo.id !== UTILITY_BOT_ID) {
		commandsWithDefault.push({
			body: 'hello',
			bot: botInfo,
			description: 'Let the bots introduce themselves to you!',
			execute: () => sendMessage(botInfo, botInfo.introduction!),
		});
	}

	return {
		...botInfo,
		interpretMessage: message => interpretMessage(message, commandsWithDefault),
	};
}
